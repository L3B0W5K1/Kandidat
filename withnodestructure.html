<!DOChasControl html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map with Nodes</title>
    <style>
      svg {
        border: 1px solid black;
      }
      .node {
        fill: blue;
      }
      .player {
        fill: red;
        stroke: gold;
        stroke-width: 2;
      }
      .connection {
        stroke: black;
        stroke-width: 2;
      }
      .path {
        stroke: yellow;
        stroke-width: 4;
        stroke-dasharray: 5, 5;
      }
      .index-label {
        font-family: Arial, sans-serif;
        font-size: 12px;
        fill: white;
        text-anchor: middle;
        dominant-baseline: central;
      }
      .control {
        fill: purple;
      }
      .control-label {
        font-family: Arial, sans-serif;
        font-size: 12px;
        fill: purple;
        text-anchor: middle;
        dominant-baseline: central;
      }
    </style>
  </head>
  <body>
    <svg id="map" width="1000" height="1000"></svg>
    <script>
      const mapData = {
        nodes: [
          { id: 1, x: 200, y: 200, neighbors: [2, 5, 4, 6], hasControl: false },
          { id: 2, x: 300, y: 200, neighbors: [1, 3, 5], hasControl: false },
          {
            id: 3,
            x: 300,
            y: 100,
            neighbors: [2, 15, 14],
            hasControl: true,
            controlNumber: 1,
          },
          {
            id: 4,
            x: 100,
            y: 200,
            neighbors: [1],
            hasControl: true,
            controlNumber: 2,
          },
          { id: 5, x: 250, y: 150, neighbors: [1, 2], hasControl: false },
          { id: 6, x: 150, y: 100, neighbors: [1, 7], hasControl: false },
          { id: 7, x: 100, y: 50, neighbors: [6, 8], hasControl: false },
          {
            id: 8,
            x: 50,
            y: 100,
            neighbors: [7, 9],
            hasControl: true,
            controlNumber: 3,
          },
          { id: 9, x: 50, y: 300, neighbors: [8, 10], hasControl: false },
          { id: 10, x: 100, y: 350, neighbors: [9, 11], hasControl: false },
          { id: 11, x: 200, y: 300, neighbors: [10, 12], hasControl: false },
          {
            id: 12,
            x: 300,
            y: 350,
            neighbors: [11, 13],
            hasControl: true,
            controlNumber: 4,
          },
          { id: 13, x: 350, y: 300, neighbors: [12, 14], hasControl: false },
          {
            id: 14,
            x: 350,
            y: 100,
            neighbors: [13, 15, 3, 16],
            hasControl: false,
          },
          { id: 15, x: 300, y: 50, neighbors: [14, 3], hasControl: false },
          { id: 16, x: 400, y: 200, neighbors: [14, 17], hasControl: false },
          {
            id: 17,
            x: 450,
            y: 150,
            neighbors: [16, 18],
            hasControl: true,
            controlNumber: 5,
          },
          { id: 18, x: 500, y: 200, neighbors: [17, 19], hasControl: false },
          { id: 19, x: 550, y: 250, neighbors: [18, 20], hasControl: false },
          { id: 20, x: 600, y: 300, neighbors: [19], hasControl: false },
        ],

        player: {
          id: "player",
          x: 200,
          y: 200,
          neighbors: [1],
          path: [],
        },
        controlsCollected: [],
        totalControls: 5,
        nextControlToCollect: 1, // Track the next control number to collect
      };

      let startingNode = 1;
      let controlsToCollect = [3,4,8,12,17]; // fixa så att denna löser sig själv


      const svg = document.getElementById("map");

      function renderMap() {
        svg.innerHTML = "";

        // Add background image
        const backgroundImage = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image"
        );
        backgroundImage.setAttribute("href", "karta1.jpeg");
        backgroundImage.setAttribute("width", "1000");
        backgroundImage.setAttribute("height", "1000");
        svg.appendChild(backgroundImage);

        // Add connections
        const renderedConnections = new Set();
        mapData.nodes.forEach((node) => {
          node.neighbors.forEach((neighborId) => {
            const neighbor = mapData.nodes.find((n) => n.id === neighborId);
            const connectionKey = [node.id, neighborId].sort().join("-");
            if (!renderedConnections.has(connectionKey)) {
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("class", "connection");
              line.setAttribute("x1", node.x);
              line.setAttribute("y1", node.y);
              line.setAttribute("x2", neighbor.x);
              line.setAttribute("y2", neighbor.y);
              svg.insertBefore(line, svg.firstChild.nextSibling);
              renderedConnections.add(connectionKey);
            }
          });
        });

        // Add nodes and controls
        mapData.nodes.forEach((node) => {
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute(
            "class",
            node.hasControl === true &&
              !mapData.controlsCollected.includes(node.controlNumber)
              ? "control"
              : "node"
          ); //replaces control with node if collected
          circle.setAttribute("cx", node.x);
          circle.setAttribute("cy", node.y);
          circle.setAttribute("r", "10");
          svg.appendChild(circle);

          if (node.hasControl === true) {
            const controlLabel = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            controlLabel.setAttribute("class", "control-label");
            controlLabel.setAttribute("x", node.x + 15);
            controlLabel.setAttribute("y", node.y - 10);
            controlLabel.textContent = node.controlNumber;
            svg.appendChild(controlLabel);
          }

          // Add index label for nodes
          const label = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          label.setAttribute("class", "index-label");
          label.setAttribute("x", node.x);
          label.setAttribute("y", node.y);
          if (mapData.player.neighbors.includes(node.id)) {
            label.textContent = mapData.player.neighbors.indexOf(node.id) + 1;
          }
          svg.appendChild(label);
        });

        // Add player
        const playerCircle = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        playerCircle.setAttribute("class", "player");
        playerCircle.setAttribute("cx", mapData.player.x);
        playerCircle.setAttribute("cy", mapData.player.y);
        playerCircle.setAttribute("r", "10");
        svg.appendChild(playerCircle);
      }

      function calculateDistance(a, b) {
        // Simple Euclidean distance for demonstration
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
      }

      function findShortestPath(graph, startId, endId) {
        let distances = {};
        let prev = {};
        let visited = new Set();
        let pq = []; // Using an array as a priority queue

        graph.nodes.forEach((node) => {
          distances[node.id] = node.id === startId ? 0 : Infinity;
          pq.push({ nodeId: node.id, dist: distances[node.id] });
          prev[node.id] = null;
        });

        pq.sort((a, b) => a.dist - b.dist); // Sort priority queue

        while (pq.length !== 0) {
          let { nodeId } = pq.shift(); // Get the node with the smallest distance
          visited.add(nodeId);

          let node = graph.nodes.find((n) => n.id === nodeId);
          if (nodeId === endId) break; // Stop if we reached the end node

          node.neighbors.forEach((neighborId) => {
            if (visited.has(neighborId)) return;
            let neighbor = graph.nodes.find((n) => n.id === neighborId);
            let alt = distances[nodeId] + calculateDistance(node, neighbor);
            if (alt < distances[neighborId]) {
              distances[neighborId] = alt;
              prev[neighborId] = nodeId;
              pq.push({ nodeId: neighborId, dist: alt }); // Reinsert with new distance
              pq.sort((a, b) => a.dist - b.dist); // Re-sort priority queue
            }
          });
        }

        // Reconstruct the path from start to end
        let path = [];
        for (let at = endId; at !== null; at = prev[at]) {
          path.push(at);
        }
        path.reverse();

        return path.length > 1 ? path : null; // Return path if exists
      }

      function findPathThroughControls(graph, controls, startNode) {
        let path = [startNode];
        let currentStart = startNode;

        controls.forEach((control) => {
          let segment = findShortestPath(graph, currentStart, control);
          if (segment) {
            // Combine paths without duplicating the connecting nodes
            path = path.concat(segment.slice(1));
            currentStart = control;
          }
        });

        return path;
      }

      function drawFinalPath() {
        if (mapData.player.path.length > 1) {
          for (let i = 0; i < mapData.player.path.length - 1; i++) {
            const startNode = mapData.nodes.find(
              (node) => node.id === mapData.player.path[i]
            );
            const endNode = mapData.nodes.find(
              (node) => node.id === mapData.player.path[i + 1]
            );
            const pathLine = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            pathLine.setAttribute("class", "path");
            pathLine.setAttribute("x1", startNode.x);
            pathLine.setAttribute("y1", startNode.y);
            pathLine.setAttribute("x2", endNode.x);
            pathLine.setAttribute("y2", endNode.y);
            svg.appendChild(pathLine); 
          }
        }
      }

      function updatePlayerPosition(newNodeId) {
        const newNode = mapData.nodes.find((node) => node.id === newNodeId);
        mapData.player.x = newNode.x;
        mapData.player.y = newNode.y;
        mapData.player.neighbors = newNode.neighbors;
        mapData.player.path.push(newNodeId);

        if (
          newNode.hasControl === true &&
          newNode.controlNumber === mapData.nextControlToCollect
        ) {
          mapData.controlsCollected.push(newNode.controlNumber);
          mapData.nextControlToCollect++;
        }

        if (mapData.controlsCollected.length === mapData.totalControls) {
          alert(
            "Game completed! Path taken: " + mapData.player.path.join(", ")
          );

          drawFinalPath();
          let fullPath = findPathThroughControls(mapData, controlsToCollect, startingNode);
            alert("Shortest path:" + fullPath)
        } else {
          renderMap();
        }
      }

      document.addEventListener("keydown", (event) => {
        const key = event.key;
        const targetIndex = parseInt(key) - 1;
        const targetNodeId = mapData.player.neighbors[targetIndex];
        if (targetNodeId !== undefined) {
          updatePlayerPosition(targetNodeId);
        }
      });

      renderMap();
    </script>
  </body>
</html>
